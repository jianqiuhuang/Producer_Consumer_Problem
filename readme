****************Description of how the program works***************************
Program uses init() to initialize the queue and create threads
Each thread performs designated tasks. Before exiting the program, program checks whether all threads have sucessfully completes (in clear()).

****************Problems***********************************
During Wednesday's lecture, Prof. Lewis mentioned he will not be testing the case where num_students < students_per_assignment, therefore, the program does not take care such case. Furthermore, it wouldn't make sense for this case to occur because the requirement is to have each student to run each assignment at most once.

****************Details of professor threads**********************************
In each professor thread,  a lock (prof_id_update) is used to update professors id, this will assure each professor has an unique thread id. A lock is needed here because parameters are pass as pointers, which means all threads share the same parameters (or these parameters are the same instances)
After printing the starting statement, the professor thread will perform assignment writing, each thread will assign num_assigning time with a random number of assignments (random hours) per assigning. Now, before actually assigning assignments to the queue, prfessor uses another mutex lock (queue_lock) to update the queue. In this critical section, professor check whether is safe to write to the queue. If the queue is full, threads will be waiting on a condition variable called - empty, which will be signaled by student treads. For every assignment being added to the queue, the professor signals students_per_assignment students with condition variable - full (not empty). At the very end of professors_write(), another lock (professor_count_update) is used to update professor_count. This variable keeps track of how many professor threads have exited. This variable will be used in student threads to signal students when to exit.

****************Details of student threads********************************
In each student thread, a lock (stud_id_update) is uesd to update student id, this will assure each thread has an unique thread id (same reasoning as for professor threads). Each student will be constantly checking the queue to see if there's any assignments available to read. When checking the queue, student has exclusive acess to the queue. That is, students will lock the queue with queue_lock. If there is assignments ready to be read, then student first check whether the assignment has been done before. If the assignment was completed by the same student before, then the student will skip this assignment and wait for another assignment. If the assignment has not been completed before, then load the  assignment to a temporary structure. Then, Update the queue, release the lock, and perform assignment outside of critical section. In the case where the queue is temporarily empty, students will wait on a condition variable call full, which is signal by professors. After each student takes assignment from the queue, student will signal professors (if one assignment is finished) with the conditional variable empty (queue is not full). Note that students will be in the while loop as long as all professors have not exited. We do this by using the professor_count variable updated from the professor_write(). If professor_count == queue_size, then all professors have exited. But, we still need to check if there're any more assignments in the queue. If yes, then finish all the assignments then students can exit.




